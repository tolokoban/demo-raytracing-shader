{"intl":"","src":"window['#webgl.plane']=function(exports,module){  \"use strict\";\r\nvar Widget = require(\"wdg\");\r\n\r\n/**\r\n * @example\r\n * var Plane = require(\"webgl.plane\");\r\n * var instance = new Plane();\r\n * @class Plane\r\n */\r\nvar Plane = function(args) {\r\n    if (typeof args === 'undefined') args = {};\r\n    if (typeof args.canvasId === 'undefined') args.canvasId = \"glcanvas\";\r\n    if (typeof args.fragmentShaderId === 'undefined') args.fragmentShaderId = \"fragment-shader\";\r\n    if (typeof args.uniform === 'undefined') args.uniform = {};\r\n    if (typeof args.texture === 'undefined') args.texture = {};\r\n    if (typeof args.resolution === 'undefined') args.resolution = 2;\r\n\r\n    this._args = args;\r\n\r\n    var canvasId = args.canvasId;\r\n    var canvas = document.getElementById(canvasId);\r\n    if (!canvas) {\r\n        throw Error(\"Canvas not found with this id: \" + canvasId);\r\n    }\r\n    var fragmentShaderId = args.fragmentShaderId;\r\n    var fragmentShaderElement = document.getElementById(fragmentShaderId);\r\n    if (!fragmentShaderElement) {\r\n        throw Error(\"Fragment shader not found with this id: \" + canvasId);\r\n    }\r\n    var fragmentShader = fragmentShaderElement.textContent.trim();\r\n    var rect = canvas.getBoundingClientRect();\r\n    var W = rect.width;\r\n    var H = rect.height;\r\n    canvas.setAttribute(\"width\", W / args.resolution);\r\n    canvas.setAttribute(\"height\", H / args.resolution);\r\n    var gl = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\r\n\r\n    initShaders.call(this, gl, fragmentShader);\r\n    this._squareVerticesBuffer = initBuffers(gl, W / args.resolution, H / args.resolution);\r\n\r\n    var key, val, texture, textureIndex = 0;\r\n    for (key in args.texture) {\r\n        val = args.texture[key];\r\n        if (typeof val.data === 'undefined') {\r\n            throw Error(\"Missing texture attribute \\\"data\\\" for \\\"\" + key + \"\\\"!\");\r\n        }\r\n        if (typeof val.width === 'undefined') {\r\n            throw Error(\"Missing texture attribute \\\"width\\\" for \\\"\" + key + \"\\\"!\");\r\n        }\r\n\r\n        if (!Array.isArray(val.data)) {\r\n            throw Error(\"Textures must be arrays of Uint8! It is not the case of \\\"\" + key + \"\\\"!\");\r\n        }\r\n        // Make sur data is an array of UNSIGNED_BYTE.\r\n        val.data = new Uint8Array(val.data);\r\n        var tex = gl.createTexture();\r\n        gl.bindTexture(gl.TEXTURE_2D, tex);\r\n        var width = val.width;\r\n        var height = Math.floor((val.data.length >> 2) / width);\r\n        gl.texImage2D(\r\n            gl.TEXTURE_2D,     // target\r\n            0,                 // level\r\n            gl.RGBA,           // internal format\r\n            width, height,     // width, height\r\n            0,                 // border\r\n            gl.RGBA,           // format\r\n            gl.UNSIGNED_BYTE,  // type\r\n            val.data           // data\r\n        );\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\r\n        gl.generateMipmap(gl.TEXTURE_2D);\r\n        var location = gl.getUniformLocation(this._shaderProgram, key);\r\n        gl.activeTexture(gl.TEXTURE0 + textureIndex);\r\n        gl.bindTexture(gl.TEXTURE_2D, tex);\r\n        gl.uniform1i(location, textureIndex);\r\n        textureIndex++;\r\n    }\r\n\r\n    this._gl = gl;\r\n    this._started = false;\r\n};\r\n\r\n\r\n/**\r\n * @return void\r\n */\r\nPlane.prototype.start = function() {\r\n    var that = this;\r\n    var gl = this._gl;\r\n    var uniform = this._args.uniform;\r\n    this._started = true;\r\n\r\n    var time0 = 0;\r\n    var nbFrames = 20;\r\n    var fps = document.getElementById(\"fps\");\r\n\r\n    function render(time) {\r\n        // Computing the FPS (Frames Per Second).\r\n        if (time0 == 0) {\r\n            time0 = time;\r\n            nbFrames = 20;\r\n        } else {\r\n            nbFrames--;\r\n            if (nbFrames <= 0) {\r\n                fps.textContent = Math.floor(.5 + 20000 / (time - time0)) + \" fps\";\r\n                time0 = time;\r\n                nbFrames = 20;\r\n            }\r\n        }\r\n\r\n        //gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, that._squareVerticesBuffer);\r\n        gl.vertexAttribPointer(that._vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);\r\n\r\n        var f = that._args.render;\r\n        if (typeof f === 'function') {\r\n            f(time, uniform);\r\n        }\r\n\r\n        var key, val;\r\n        for (key in uniform) {\r\n            val = uniform[key];\r\n            gl.uniform1f(gl.getUniformLocation(that._shaderProgram, key), val);\r\n        }\r\n        // Draw the square.\r\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n        if (that._started) {\r\n            window.requestAnimationFrame(render);\r\n        }\r\n    }\r\n\r\n    window.requestAnimationFrame(render);\r\n};\r\n\r\n\r\nfunction initShaders(gl, code) {\r\n    //  var fragmentShader = getShader(gl, code);\r\n    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n    gl.shaderSource(fragmentShader, code);\r\n    gl.compileShader(fragmentShader);\r\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\r\n        throw Error(\r\n            \"An error occurred compiling the fragment shaders:\\n\"\r\n                + gl.getShaderInfoLog(fragmentShader));\r\n    }\r\n\r\n    var vertexShader = gl.createShader(gl.VERTEX_SHADER);\r\n    gl.shaderSource(vertexShader, \"attribute vec3 aVertexPosition;\\nvarying lowp vec3 vPoint;\\nvoid main(void) {\\n  float x = aVertexPosition[0];\\n  float y = aVertexPosition[1];\\n  if (x > 0.0) {\\n    if (y > 0.0) {\\n      gl_Position = vec4(1.0, 1.0, 0.0, 1.0);\\n    } else {\\n      gl_Position = vec4(1.0, -1.0, 0.0, 1.0);\\n    }\\n  } else {\\n    if (y > 0.0) {\\n      gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);\\n    } else {\\n      gl_Position = vec4(-1.0, -1.0, 0.0, 1.0);\\n    }\\n  }\\n  vPoint = aVertexPosition;\\n}\\n\");\r\n    gl.compileShader(vertexShader);\r\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\r\n        throw Error(\r\n            \"An error occurred compiling the vertex shaders:\\n\"\r\n                + gl.getShaderInfoLog(vertexShader));\r\n    }\r\n\r\n    var shaderProgram = gl.createProgram();\r\n    gl.attachShader(shaderProgram, vertexShader);\r\n    gl.attachShader(shaderProgram, fragmentShader);\r\n    gl.linkProgram(shaderProgram);\r\n\r\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n        throw Error(\"Unable to initialize the shader program.\");\r\n    }\r\n\r\n    gl.useProgram(shaderProgram);\r\n\r\n    var vertexPositionAttribute = gl.getAttribLocation(shaderProgram, \"aVertexPosition\");\r\n    gl.enableVertexAttribArray(vertexPositionAttribute);\r\n\r\n    this._shaderProgram = shaderProgram;\r\n    this._vertexPositionAttribute = vertexPositionAttribute;\r\n}\r\n\r\nfunction initBuffers(gl, W, H) {\r\n    var squareVerticesBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, squareVerticesBuffer);\r\n    var vertices = [\r\n        W/2,  -H/2,  0.0,\r\n            -W/2, -H/2,  0.0,\r\n        W/2,  H/2, 0.0,\r\n            -W/2, H/2, 0.0\r\n    ];\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    return squareVerticesBuffer;\r\n}\r\n\r\nmodule.exports = Plane;\r\n }\r\n","zip":"window[\"#webgl.plane\"]=function(e,t){\"use strict\";function r(e,t){var r=e.createShader(e.FRAGMENT_SHADER);if(e.shaderSource(r,t),e.compileShader(r),!e.getShaderParameter(r,e.COMPILE_STATUS))throw Error(\"An error occurred compiling the fragment shaders:\\n\"+e.getShaderInfoLog(r));var a=e.createShader(e.VERTEX_SHADER);if(e.shaderSource(a,\"attribute vec3 aVertexPosition;\\nvarying lowp vec3 vPoint;\\nvoid main(void) {\\n  float x = aVertexPosition[0];\\n  float y = aVertexPosition[1];\\n  if (x > 0.0) {\\n    if (y > 0.0) {\\n      gl_Position = vec4(1.0, 1.0, 0.0, 1.0);\\n    } else {\\n      gl_Position = vec4(1.0, -1.0, 0.0, 1.0);\\n    }\\n  } else {\\n    if (y > 0.0) {\\n      gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);\\n    } else {\\n      gl_Position = vec4(-1.0, -1.0, 0.0, 1.0);\\n    }\\n  }\\n  vPoint = aVertexPosition;\\n}\\n\"),e.compileShader(a),!e.getShaderParameter(a,e.COMPILE_STATUS))throw Error(\"An error occurred compiling the vertex shaders:\\n\"+e.getShaderInfoLog(a));var i=e.createProgram();if(e.attachShader(i,a),e.attachShader(i,r),e.linkProgram(i),!e.getProgramParameter(i,e.LINK_STATUS))throw Error(\"Unable to initialize the shader program.\");e.useProgram(i);var n=e.getAttribLocation(i,\"aVertexPosition\");e.enableVertexAttribArray(n),this._shaderProgram=i,this._vertexPositionAttribute=n}function a(e,t,r){var a=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,a);var i=[t/2,-r/2,0,-t/2,-r/2,0,t/2,r/2,0,-t/2,r/2,0];return e.bufferData(e.ARRAY_BUFFER,new Float32Array(i),e.STATIC_DRAW),a}var i=(require(\"wdg\"),function(e){\"undefined\"==typeof e&&(e={}),\"undefined\"==typeof e.canvasId&&(e.canvasId=\"glcanvas\"),\"undefined\"==typeof e.fragmentShaderId&&(e.fragmentShaderId=\"fragment-shader\"),\"undefined\"==typeof e.uniform&&(e.uniform={}),\"undefined\"==typeof e.texture&&(e.texture={}),\"undefined\"==typeof e.resolution&&(e.resolution=2),this._args=e;var t=e.canvasId,i=document.getElementById(t);if(!i)throw Error(\"Canvas not found with this id: \"+t);var n=e.fragmentShaderId,o=document.getElementById(n);if(!o)throw Error(\"Fragment shader not found with this id: \"+t);var d=o.textContent.trim(),s=i.getBoundingClientRect(),f=s.width,u=s.height;i.setAttribute(\"width\",f/e.resolution),i.setAttribute(\"height\",u/e.resolution);var h=i.getContext(\"webgl\")||i.getContext(\"experimental-webgl\");r.call(this,h,d),this._squareVerticesBuffer=a(h,f/e.resolution,u/e.resolution);var g,E,c=0;for(g in e.texture){if(E=e.texture[g],\"undefined\"==typeof E.data)throw Error('Missing texture attribute \"data\" for \"'+g+'\"!');if(\"undefined\"==typeof E.width)throw Error('Missing texture attribute \"width\" for \"'+g+'\"!');if(!Array.isArray(E.data))throw Error('Textures must be arrays of Uint8! It is not the case of \"'+g+'\"!');E.data=new Uint8Array(E.data);var m=h.createTexture();h.bindTexture(h.TEXTURE_2D,m);var l=E.width,_=Math.floor((E.data.length>>2)/l);h.texImage2D(h.TEXTURE_2D,0,h.RGBA,l,_,0,h.RGBA,h.UNSIGNED_BYTE,E.data),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_MAG_FILTER,h.LINEAR),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_MIN_FILTER,h.LINEAR_MIPMAP_NEAREST),h.generateMipmap(h.TEXTURE_2D);var v=h.getUniformLocation(this._shaderProgram,g);h.activeTexture(h.TEXTURE0+c),h.bindTexture(h.TEXTURE_2D,m),h.uniform1i(v,c),c++}this._gl=h,this._started=!1});i.prototype.start=function(){function e(d){0==i?(i=d,n=20):(n--,0>=n&&(o.textContent=Math.floor(.5+2e4/(d-i))+\" fps\",i=d,n=20)),r.bindBuffer(r.ARRAY_BUFFER,t._squareVerticesBuffer),r.vertexAttribPointer(t._vertexPositionAttribute,3,r.FLOAT,!1,0,0);var s=t._args.render;\"function\"==typeof s&&s(d,a);var f,u;for(f in a)u=a[f],r.uniform1f(r.getUniformLocation(t._shaderProgram,f),u);r.drawArrays(r.TRIANGLE_STRIP,0,4),t._started&&window.requestAnimationFrame(e)}var t=this,r=this._gl,a=this._args.uniform;this._started=!0;var i=0,n=20,o=document.getElementById(\"fps\");window.requestAnimationFrame(e)},t.exports=i};\n//# sourceMappingURL=webgl.plane.js.map","map":{"version":3,"file":"webgl.plane.js.map","sources":["webgl.plane.js"],"sourcesContent":["window['#webgl.plane']=function(exports,module){  \"use strict\";\r\nvar Widget = require(\"wdg\");\r\n\r\n/**\r\n * @example\r\n * var Plane = require(\"webgl.plane\");\r\n * var instance = new Plane();\r\n * @class Plane\r\n */\r\nvar Plane = function(args) {\r\n    if (typeof args === 'undefined') args = {};\r\n    if (typeof args.canvasId === 'undefined') args.canvasId = \"glcanvas\";\r\n    if (typeof args.fragmentShaderId === 'undefined') args.fragmentShaderId = \"fragment-shader\";\r\n    if (typeof args.uniform === 'undefined') args.uniform = {};\r\n    if (typeof args.texture === 'undefined') args.texture = {};\r\n    if (typeof args.resolution === 'undefined') args.resolution = 2;\r\n\r\n    this._args = args;\r\n\r\n    var canvasId = args.canvasId;\r\n    var canvas = document.getElementById(canvasId);\r\n    if (!canvas) {\r\n        throw Error(\"Canvas not found with this id: \" + canvasId);\r\n    }\r\n    var fragmentShaderId = args.fragmentShaderId;\r\n    var fragmentShaderElement = document.getElementById(fragmentShaderId);\r\n    if (!fragmentShaderElement) {\r\n        throw Error(\"Fragment shader not found with this id: \" + canvasId);\r\n    }\r\n    var fragmentShader = fragmentShaderElement.textContent.trim();\r\n    var rect = canvas.getBoundingClientRect();\r\n    var W = rect.width;\r\n    var H = rect.height;\r\n    canvas.setAttribute(\"width\", W / args.resolution);\r\n    canvas.setAttribute(\"height\", H / args.resolution);\r\n    var gl = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\r\n\r\n    initShaders.call(this, gl, fragmentShader);\r\n    this._squareVerticesBuffer = initBuffers(gl, W / args.resolution, H / args.resolution);\r\n\r\n    var key, val, texture, textureIndex = 0;\r\n    for (key in args.texture) {\r\n        val = args.texture[key];\r\n        if (typeof val.data === 'undefined') {\r\n            throw Error(\"Missing texture attribute \\\"data\\\" for \\\"\" + key + \"\\\"!\");\r\n        }\r\n        if (typeof val.width === 'undefined') {\r\n            throw Error(\"Missing texture attribute \\\"width\\\" for \\\"\" + key + \"\\\"!\");\r\n        }\r\n\r\n        if (!Array.isArray(val.data)) {\r\n            throw Error(\"Textures must be arrays of Uint8! It is not the case of \\\"\" + key + \"\\\"!\");\r\n        }\r\n        // Make sur data is an array of UNSIGNED_BYTE.\r\n        val.data = new Uint8Array(val.data);\r\n        var tex = gl.createTexture();\r\n        gl.bindTexture(gl.TEXTURE_2D, tex);\r\n        var width = val.width;\r\n        var height = Math.floor((val.data.length >> 2) / width);\r\n        gl.texImage2D(\r\n            gl.TEXTURE_2D,     // target\r\n            0,                 // level\r\n            gl.RGBA,           // internal format\r\n            width, height,     // width, height\r\n            0,                 // border\r\n            gl.RGBA,           // format\r\n            gl.UNSIGNED_BYTE,  // type\r\n            val.data           // data\r\n        );\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\r\n        gl.generateMipmap(gl.TEXTURE_2D);\r\n        var location = gl.getUniformLocation(this._shaderProgram, key);\r\n        gl.activeTexture(gl.TEXTURE0 + textureIndex);\r\n        gl.bindTexture(gl.TEXTURE_2D, tex);\r\n        gl.uniform1i(location, textureIndex);\r\n        textureIndex++;\r\n    }\r\n\r\n    this._gl = gl;\r\n    this._started = false;\r\n};\r\n\r\n\r\n/**\r\n * @return void\r\n */\r\nPlane.prototype.start = function() {\r\n    var that = this;\r\n    var gl = this._gl;\r\n    var uniform = this._args.uniform;\r\n    this._started = true;\r\n\r\n    var time0 = 0;\r\n    var nbFrames = 20;\r\n    var fps = document.getElementById(\"fps\");\r\n\r\n    function render(time) {\r\n        // Computing the FPS (Frames Per Second).\r\n        if (time0 == 0) {\r\n            time0 = time;\r\n            nbFrames = 20;\r\n        } else {\r\n            nbFrames--;\r\n            if (nbFrames <= 0) {\r\n                fps.textContent = Math.floor(.5 + 20000 / (time - time0)) + \" fps\";\r\n                time0 = time;\r\n                nbFrames = 20;\r\n            }\r\n        }\r\n\r\n        //gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, that._squareVerticesBuffer);\r\n        gl.vertexAttribPointer(that._vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);\r\n\r\n        var f = that._args.render;\r\n        if (typeof f === 'function') {\r\n            f(time, uniform);\r\n        }\r\n\r\n        var key, val;\r\n        for (key in uniform) {\r\n            val = uniform[key];\r\n            gl.uniform1f(gl.getUniformLocation(that._shaderProgram, key), val);\r\n        }\r\n        // Draw the square.\r\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n        if (that._started) {\r\n            window.requestAnimationFrame(render);\r\n        }\r\n    }\r\n\r\n    window.requestAnimationFrame(render);\r\n};\r\n\r\n\r\nfunction initShaders(gl, code) {\r\n    //  var fragmentShader = getShader(gl, code);\r\n    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n    gl.shaderSource(fragmentShader, code);\r\n    gl.compileShader(fragmentShader);\r\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\r\n        throw Error(\r\n            \"An error occurred compiling the fragment shaders:\\n\"\r\n                + gl.getShaderInfoLog(fragmentShader));\r\n    }\r\n\r\n    var vertexShader = gl.createShader(gl.VERTEX_SHADER);\r\n    gl.shaderSource(vertexShader, \"attribute vec3 aVertexPosition;\\nvarying lowp vec3 vPoint;\\nvoid main(void) {\\n  float x = aVertexPosition[0];\\n  float y = aVertexPosition[1];\\n  if (x > 0.0) {\\n    if (y > 0.0) {\\n      gl_Position = vec4(1.0, 1.0, 0.0, 1.0);\\n    } else {\\n      gl_Position = vec4(1.0, -1.0, 0.0, 1.0);\\n    }\\n  } else {\\n    if (y > 0.0) {\\n      gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);\\n    } else {\\n      gl_Position = vec4(-1.0, -1.0, 0.0, 1.0);\\n    }\\n  }\\n  vPoint = aVertexPosition;\\n}\\n\");\r\n    gl.compileShader(vertexShader);\r\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\r\n        throw Error(\r\n            \"An error occurred compiling the vertex shaders:\\n\"\r\n                + gl.getShaderInfoLog(vertexShader));\r\n    }\r\n\r\n    var shaderProgram = gl.createProgram();\r\n    gl.attachShader(shaderProgram, vertexShader);\r\n    gl.attachShader(shaderProgram, fragmentShader);\r\n    gl.linkProgram(shaderProgram);\r\n\r\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n        throw Error(\"Unable to initialize the shader program.\");\r\n    }\r\n\r\n    gl.useProgram(shaderProgram);\r\n\r\n    var vertexPositionAttribute = gl.getAttribLocation(shaderProgram, \"aVertexPosition\");\r\n    gl.enableVertexAttribArray(vertexPositionAttribute);\r\n\r\n    this._shaderProgram = shaderProgram;\r\n    this._vertexPositionAttribute = vertexPositionAttribute;\r\n}\r\n\r\nfunction initBuffers(gl, W, H) {\r\n    var squareVerticesBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, squareVerticesBuffer);\r\n    var vertices = [\r\n        W/2,  -H/2,  0.0,\r\n            -W/2, -H/2,  0.0,\r\n        W/2,  H/2, 0.0,\r\n            -W/2, H/2, 0.0\r\n    ];\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    return squareVerticesBuffer;\r\n}\r\n\r\nmodule.exports = Plane;\r\n }\r\n"],"names":["window","exports","module","initShaders","gl","code","fragmentShader","createShader","FRAGMENT_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","Error","getShaderInfoLog","vertexShader","VERTEX_SHADER","shaderProgram","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","useProgram","vertexPositionAttribute","getAttribLocation","enableVertexAttribArray","this","_shaderProgram","_vertexPositionAttribute","initBuffers","W","H","squareVerticesBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","vertices","bufferData","Float32Array","STATIC_DRAW","Plane","require","args","canvasId","fragmentShaderId","uniform","texture","resolution","_args","canvas","document","getElementById","fragmentShaderElement","textContent","trim","rect","getBoundingClientRect","width","height","setAttribute","getContext","call","_squareVerticesBuffer","key","val","textureIndex","data","Array","isArray","Uint8Array","tex","createTexture","bindTexture","TEXTURE_2D","Math","floor","length","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","LINEAR_MIPMAP_NEAREST","generateMipmap","location","getUniformLocation","activeTexture","TEXTURE0","uniform1i","_gl","_started","prototype","start","render","time","time0","nbFrames","fps","that","vertexAttribPointer","FLOAT","f","uniform1f","drawArrays","TRIANGLE_STRIP","requestAnimationFrame"],"mappings":"AAAAA,OAAO,gBAAgB,SAASC,EAAQC,GAAU,YAwIlD,SAASC,GAAYC,EAAIC,GAErB,GAAIC,GAAiBF,EAAGG,aAAaH,EAAGI,gBAGxC,IAFAJ,EAAGK,aAAaH,EAAgBD,GAChCD,EAAGM,cAAcJ,IACZF,EAAGO,mBAAmBL,EAAgBF,EAAGQ,gBAC1C,KAAMC,OACF,sDACMT,EAAGU,iBAAiBR,GAGlC,IAAIS,GAAeX,EAAGG,aAAaH,EAAGY,cAGtC,IAFAZ,EAAGK,aAAaM,EAAc,0eAC9BX,EAAGM,cAAcK,IACZX,EAAGO,mBAAmBI,EAAcX,EAAGQ,gBACxC,KAAMC,OACF,oDACMT,EAAGU,iBAAiBC,GAGlC,IAAIE,GAAgBb,EAAGc,eAKvB,IAJAd,EAAGe,aAAaF,EAAeF,GAC/BX,EAAGe,aAAaF,EAAeX,GAC/BF,EAAGgB,YAAYH,IAEVb,EAAGiB,oBAAoBJ,EAAeb,EAAGkB,aAC1C,KAAMT,OAAM,2CAGhBT,GAAGmB,WAAWN,EAEd,IAAIO,GAA0BpB,EAAGqB,kBAAkBR,EAAe,kBAClEb,GAAGsB,wBAAwBF,GAE3BG,KAAKC,eAAiBX,EACtBU,KAAKE,yBAA2BL,EAGpC,QAASM,GAAY1B,EAAI2B,EAAGC,GACxB,GAAIC,GAAuB7B,EAAG8B,cAC9B9B,GAAG+B,WAAW/B,EAAGgC,aAAcH,EAC/B,IAAII,IACAN,EAAE,GAAKC,EAAE,EAAI,GACRD,EAAE,GAAIC,EAAE,EAAI,EACjBD,EAAE,EAAIC,EAAE,EAAG,GACND,EAAE,EAAGC,EAAE,EAAG,EAGnB,OADA5B,GAAGkC,WAAWlC,EAAGgC,aAAc,GAAIG,cAAaF,GAAWjC,EAAGoC,aACvDP,EAvLX,GAQIQ,IARSC,QAAQ,OAQT,SAASC,GACG,mBAATA,KAAsBA,MACJ,mBAAlBA,GAAKC,WAA0BD,EAAKC,SAAW,YACrB,mBAA1BD,GAAKE,mBAAkCF,EAAKE,iBAAmB,mBAC9C,mBAAjBF,GAAKG,UAAyBH,EAAKG,YAClB,mBAAjBH,GAAKI,UAAyBJ,EAAKI,YACf,mBAApBJ,GAAKK,aAA4BL,EAAKK,WAAa,GAE9DrB,KAAKsB,MAAQN,CAEb,IAAIC,GAAWD,EAAKC,SAChBM,EAASC,SAASC,eAAeR,EACrC,KAAKM,EACD,KAAMrC,OAAM,kCAAoC+B,EAEpD,IAAIC,GAAmBF,EAAKE,iBACxBQ,EAAwBF,SAASC,eAAeP,EACpD,KAAKQ,EACD,KAAMxC,OAAM,2CAA6C+B,EAE7D,IAAItC,GAAiB+C,EAAsBC,YAAYC,OACnDC,EAAON,EAAOO,wBACd1B,EAAIyB,EAAKE,MACT1B,EAAIwB,EAAKG,MACbT,GAAOU,aAAa,QAAS7B,EAAIY,EAAKK,YACtCE,EAAOU,aAAa,SAAU5B,EAAIW,EAAKK,WACvC,IAAI5C,GAAK8C,EAAOW,WAAW,UAAYX,EAAOW,WAAW,qBAEzD1D,GAAY2D,KAAKnC,KAAMvB,EAAIE,GAC3BqB,KAAKoC,sBAAwBjC,EAAY1B,EAAI2B,EAAIY,EAAKK,WAAYhB,EAAIW,EAAKK,WAE3E,IAAIgB,GAAKC,EAAcC,EAAe,CACtC,KAAKF,IAAOrB,GAAKI,QAAS,CAEtB,GADAkB,EAAMtB,EAAKI,QAAQiB,GACK,mBAAbC,GAAIE,KACX,KAAMtD,OAAM,yCAA8CmD,EAAM,KAEpE,IAAyB,mBAAdC,GAAIP,MACX,KAAM7C,OAAM,0CAA+CmD,EAAM,KAGrE,KAAKI,MAAMC,QAAQJ,EAAIE,MACnB,KAAMtD,OAAM,4DAA+DmD,EAAM,KAGrFC,GAAIE,KAAO,GAAIG,YAAWL,EAAIE,KAC9B,IAAII,GAAMnE,EAAGoE,eACbpE,GAAGqE,YAAYrE,EAAGsE,WAAYH,EAC9B,IAAIb,GAAQO,EAAIP,MACZC,EAASgB,KAAKC,OAAOX,EAAIE,KAAKU,QAAU,GAAKnB,EACjDtD,GAAG0E,WACC1E,EAAGsE,WACH,EACAtE,EAAG2E,KACHrB,EAAOC,EACP,EACAvD,EAAG2E,KACH3E,EAAG4E,cACHf,EAAIE,MAER/D,EAAG6E,cAAc7E,EAAGsE,WAAYtE,EAAG8E,mBAAoB9E,EAAG+E,QAC1D/E,EAAG6E,cAAc7E,EAAGsE,WAAYtE,EAAGgF,mBAAoBhF,EAAGiF,uBAC1DjF,EAAGkF,eAAelF,EAAGsE,WACrB,IAAIa,GAAWnF,EAAGoF,mBAAmB7D,KAAKC,eAAgBoC,EAC1D5D,GAAGqF,cAAcrF,EAAGsF,SAAWxB,GAC/B9D,EAAGqE,YAAYrE,EAAGsE,WAAYH,GAC9BnE,EAAGuF,UAAUJ,EAAUrB,GACvBA,IAGJvC,KAAKiE,IAAMxF,EACXuB,KAAKkE,UAAW,GAOpBpD,GAAMqD,UAAUC,MAAQ,WAUpB,QAASC,GAAOC,GAEC,GAATC,GACAA,EAAQD,EACRE,EAAW,KAEXA,IACgB,GAAZA,IACAC,EAAI9C,YAAcqB,KAAKC,MAAM,GAAK,KAASqB,EAAOC,IAAU,OAC5DA,EAAQD,EACRE,EAAW,KAKnB/F,EAAG+B,WAAW/B,EAAGgC,aAAciE,EAAKtC,uBACpC3D,EAAGkG,oBAAoBD,EAAKxE,yBAA0B,EAAGzB,EAAGmG,OAAO,EAAO,EAAG,EAE7E,IAAIC,GAAIH,EAAKpD,MAAM+C,MACF,mBAANQ,IACPA,EAAEP,EAAMnD,EAGZ,IAAIkB,GAAKC,CACT,KAAKD,IAAOlB,GACRmB,EAAMnB,EAAQkB,GACd5D,EAAGqG,UAAUrG,EAAGoF,mBAAmBa,EAAKzE,eAAgBoC,GAAMC,EAGlE7D,GAAGsG,WAAWtG,EAAGuG,eAAgB,EAAG,GAChCN,EAAKR,UACL7F,OAAO4G,sBAAsBZ,GAxCrC,GAAIK,GAAO1E,KACPvB,EAAKuB,KAAKiE,IACV9C,EAAUnB,KAAKsB,MAAMH,OACzBnB,MAAKkE,UAAW,CAEhB,IAAIK,GAAQ,EACRC,EAAW,GACXC,EAAMjD,SAASC,eAAe,MAqClCpD,QAAO4G,sBAAsBZ,IAuDjC9F,EAAOD,QAAUwC"},"dependencies":["wdg"]}