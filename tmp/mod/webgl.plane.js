{"intl":"","src":"window['#webgl.plane']=function(exports,module){  \"use strict\";\r\nvar Widget = require(\"wdg\");\r\n\r\n/**\r\n * @example\r\n * var Plane = require(\"webgl.plane\");\r\n * var instance = new Plane();\r\n * @class Plane\r\n */\r\nvar Plane = function(args) {\r\n  if (typeof args === 'undefined') args = {};\r\n  if (typeof args.canvasId === 'undefined') args.canvasId = \"glcanvas\";\r\n  if (typeof args.fragmentShaderId === 'undefined') args.fragmentShaderId = \"fragment-shader\";\r\n  if (typeof args.uniform === 'undefined') args.uniform = {};\r\n  if (typeof args.texture === 'undefined') args.texture = {};\r\n  if (typeof args.resolution === 'undefined') args.resolution = 2;\r\n\r\n  this._args = args;\r\n\r\n  var canvasId = args.canvasId;\r\n  var canvas = document.getElementById(canvasId);\r\n  if (!canvas) {\r\n    throw Error(\"Canvas not found with this id: \" + canvasId);\r\n  }\r\n  var fragmentShaderId = args.fragmentShaderId;\r\n  var fragmentShaderElement = document.getElementById(fragmentShaderId);\r\n  if (!fragmentShaderElement) {\r\n    throw Error(\"Fragment shader not found with this id: \" + canvasId);\r\n  }\r\n  var fragmentShader = fragmentShaderElement.textContent.trim();\r\n  var rect = canvas.getBoundingClientRect();\r\n  var W = rect.width;\r\n  var H = rect.height;\r\n  canvas.setAttribute(\"width\", W / args.resolution);\r\n  canvas.setAttribute(\"height\", H / args.resolution);\r\n  var gl = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\r\n\r\n  initShaders.call(this, gl, fragmentShader);\r\n  this._squareVerticesBuffer = initBuffers(gl, W / args.resolution, H / args.resolution);\r\n\r\n  var key, val, texture, textureIndex = 0;\r\n  for (key in args.texture) {\r\n    val = args.texture[key];\r\n    if (typeof val.data === 'undefined') {\r\n      throw Error(\"Missing texture attribute \\\"data\\\" for \\\"\" + key + \"\\\"!\");\r\n    }\r\n    if (typeof val.width === 'undefined') {\r\n      throw Error(\"Missing texture attribute \\\"width\\\" for \\\"\" + key + \"\\\"!\");\r\n    }\r\n\r\n    if (!Array.isArray(val.data)) {\r\n      throw Error(\"Textures must be arrays of Uint8! It is not the case of \\\"\" + key + \"\\\"!\");\r\n    }\r\n    // Make sur data is an array of UNSIGNED_BYTE.\r\n    val.data = new Uint8Array(val.data);\r\n    var tex = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, tex);\r\n    var width = val.width;\r\n    var height = Math.floor((val.data.length >> 2) / width);\r\n    gl.texImage2D(\r\n      gl.TEXTURE_2D,     // target\r\n      0,                 // level\r\n      gl.RGBA,           // internal format\r\n      width, height,     // width, height\r\n      0,                 // border\r\n      gl.RGBA,           // format\r\n      gl.UNSIGNED_BYTE,  // type\r\n      val.data           // data\r\n    );\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\r\n    gl.generateMipmap(gl.TEXTURE_2D);\r\n    var location = gl.getUniformLocation(this._shaderProgram, key);\r\n    gl.activeTexture(gl.TEXTURE0 + textureIndex);\r\n    gl.bindTexture(gl.TEXTURE_2D, tex);\r\n    gl.uniform1i(location, textureIndex);\r\n    textureIndex++;\r\n  }\r\n\r\n  this._gl = gl;\r\n  this._started = false;\r\n};\r\n\r\n\r\n/**\r\n * @return void\r\n */\r\nPlane.prototype.start = function() {\r\n  var that = this;\r\n  var gl = this._gl;\r\n  var uniform = this._args.uniform;\r\n  this._started = true;\r\n\r\n  function render(time) {\r\n    //gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, that._squareVerticesBuffer);\r\n    gl.vertexAttribPointer(that._vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);\r\n\r\n    var f = that._args.render;\r\n    if (typeof f === 'function') {\r\n      f(time, uniform);\r\n    }\r\n\r\n    var key, val;\r\n    for (key in uniform) {\r\n      val = uniform[key];\r\n      gl.uniform1f(gl.getUniformLocation(that._shaderProgram, key), val);\r\n    }\r\n    // Draw the square.\r\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n    if (that._started) {\r\n      window.requestAnimationFrame(render);\r\n    }\r\n  }\r\n\r\n  window.requestAnimationFrame(render);\r\n};\r\n\r\n\r\nfunction initShaders(gl, code) {\r\n  //  var fragmentShader = getShader(gl, code);\r\n  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n  gl.shaderSource(fragmentShader, code);\r\n  gl.compileShader(fragmentShader);\r\n  if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\r\n    throw Error(\r\n      \"An error occurred compiling the fragment shaders:\\n\"\r\n        + gl.getShaderInfoLog(fragmentShader));\r\n  }\r\n\r\n  var vertexShader = gl.createShader(gl.VERTEX_SHADER);\r\n  gl.shaderSource(vertexShader, \"attribute vec3 aVertexPosition;\\nvarying lowp vec3 vPoint;\\nvoid main(void) {\\n  float x = aVertexPosition[0];\\n  float y = aVertexPosition[1];\\n  if (x > 0.0) {\\n    if (y > 0.0) {\\n      gl_Position = vec4(1.0, 1.0, 0.0, 1.0);\\n    } else {\\n      gl_Position = vec4(1.0, -1.0, 0.0, 1.0);\\n    }\\n  } else {\\n    if (y > 0.0) {\\n      gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);\\n    } else {\\n      gl_Position = vec4(-1.0, -1.0, 0.0, 1.0);\\n    }\\n  }\\n  vPoint = aVertexPosition;\\n}\\n\");\r\n  gl.compileShader(vertexShader);\r\n  if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\r\n    throw Error(\r\n      \"An error occurred compiling the vertex shaders:\\n\"\r\n        + gl.getShaderInfoLog(vertexShader));\r\n  }\r\n\r\n  var shaderProgram = gl.createProgram();\r\n  gl.attachShader(shaderProgram, vertexShader);\r\n  gl.attachShader(shaderProgram, fragmentShader);\r\n  gl.linkProgram(shaderProgram);\r\n\r\n  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n    throw Error(\"Unable to initialize the shader program.\");\r\n  }\r\n\r\n  gl.useProgram(shaderProgram);\r\n\r\n  var vertexPositionAttribute = gl.getAttribLocation(shaderProgram, \"aVertexPosition\");\r\n  gl.enableVertexAttribArray(vertexPositionAttribute);\r\n\r\n  this._shaderProgram = shaderProgram;\r\n  this._vertexPositionAttribute = vertexPositionAttribute;\r\n}\r\n\r\nfunction initBuffers(gl, W, H) {\r\n  var squareVerticesBuffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, squareVerticesBuffer);\r\n  var vertices = [\r\n    W/2,  -H/2,  0.0,\r\n      -W/2, -H/2,  0.0,\r\n    W/2,  H/2, 0.0,\r\n      -W/2, H/2, 0.0\r\n  ];\r\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n  return squareVerticesBuffer;\r\n}\r\n\r\nmodule.exports = Plane;\r\n }\r\n","zip":"window[\"#webgl.plane\"]=function(e,t){\"use strict\";function r(e,t){var r=e.createShader(e.FRAGMENT_SHADER);if(e.shaderSource(r,t),e.compileShader(r),!e.getShaderParameter(r,e.COMPILE_STATUS))throw Error(\"An error occurred compiling the fragment shaders:\\n\"+e.getShaderInfoLog(r));var i=e.createShader(e.VERTEX_SHADER);if(e.shaderSource(i,\"attribute vec3 aVertexPosition;\\nvarying lowp vec3 vPoint;\\nvoid main(void) {\\n  float x = aVertexPosition[0];\\n  float y = aVertexPosition[1];\\n  if (x > 0.0) {\\n    if (y > 0.0) {\\n      gl_Position = vec4(1.0, 1.0, 0.0, 1.0);\\n    } else {\\n      gl_Position = vec4(1.0, -1.0, 0.0, 1.0);\\n    }\\n  } else {\\n    if (y > 0.0) {\\n      gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);\\n    } else {\\n      gl_Position = vec4(-1.0, -1.0, 0.0, 1.0);\\n    }\\n  }\\n  vPoint = aVertexPosition;\\n}\\n\"),e.compileShader(i),!e.getShaderParameter(i,e.COMPILE_STATUS))throw Error(\"An error occurred compiling the vertex shaders:\\n\"+e.getShaderInfoLog(i));var a=e.createProgram();if(e.attachShader(a,i),e.attachShader(a,r),e.linkProgram(a),!e.getProgramParameter(a,e.LINK_STATUS))throw Error(\"Unable to initialize the shader program.\");e.useProgram(a);var n=e.getAttribLocation(a,\"aVertexPosition\");e.enableVertexAttribArray(n),this._shaderProgram=a,this._vertexPositionAttribute=n}function i(e,t,r){var i=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,i);var a=[t/2,-r/2,0,-t/2,-r/2,0,t/2,r/2,0,-t/2,r/2,0];return e.bufferData(e.ARRAY_BUFFER,new Float32Array(a),e.STATIC_DRAW),i}var a=(require(\"wdg\"),function(e){\"undefined\"==typeof e&&(e={}),\"undefined\"==typeof e.canvasId&&(e.canvasId=\"glcanvas\"),\"undefined\"==typeof e.fragmentShaderId&&(e.fragmentShaderId=\"fragment-shader\"),\"undefined\"==typeof e.uniform&&(e.uniform={}),\"undefined\"==typeof e.texture&&(e.texture={}),\"undefined\"==typeof e.resolution&&(e.resolution=2),this._args=e;var t=e.canvasId,a=document.getElementById(t);if(!a)throw Error(\"Canvas not found with this id: \"+t);var n=e.fragmentShaderId,o=document.getElementById(n);if(!o)throw Error(\"Fragment shader not found with this id: \"+t);var d=o.textContent.trim(),s=a.getBoundingClientRect(),f=s.width,u=s.height;a.setAttribute(\"width\",f/e.resolution),a.setAttribute(\"height\",u/e.resolution);var h=a.getContext(\"webgl\")||a.getContext(\"experimental-webgl\");r.call(this,h,d),this._squareVerticesBuffer=i(h,f/e.resolution,u/e.resolution);var g,E,c=0;for(g in e.texture){if(E=e.texture[g],\"undefined\"==typeof E.data)throw Error('Missing texture attribute \"data\" for \"'+g+'\"!');if(\"undefined\"==typeof E.width)throw Error('Missing texture attribute \"width\" for \"'+g+'\"!');if(!Array.isArray(E.data))throw Error('Textures must be arrays of Uint8! It is not the case of \"'+g+'\"!');E.data=new Uint8Array(E.data);var m=h.createTexture();h.bindTexture(h.TEXTURE_2D,m);var _=E.width,l=Math.floor((E.data.length>>2)/_);h.texImage2D(h.TEXTURE_2D,0,h.RGBA,_,l,0,h.RGBA,h.UNSIGNED_BYTE,E.data),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_MAG_FILTER,h.LINEAR),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_MIN_FILTER,h.LINEAR_MIPMAP_NEAREST),h.generateMipmap(h.TEXTURE_2D);var A=h.getUniformLocation(this._shaderProgram,g);h.activeTexture(h.TEXTURE0+c),h.bindTexture(h.TEXTURE_2D,m),h.uniform1i(A,c),c++}this._gl=h,this._started=!1});a.prototype.start=function(){function e(a){r.bindBuffer(r.ARRAY_BUFFER,t._squareVerticesBuffer),r.vertexAttribPointer(t._vertexPositionAttribute,3,r.FLOAT,!1,0,0);var n=t._args.render;\"function\"==typeof n&&n(a,i);var o,d;for(o in i)d=i[o],r.uniform1f(r.getUniformLocation(t._shaderProgram,o),d);r.drawArrays(r.TRIANGLE_STRIP,0,4),t._started&&window.requestAnimationFrame(e)}var t=this,r=this._gl,i=this._args.uniform;this._started=!0,window.requestAnimationFrame(e)},t.exports=a};\n//# sourceMappingURL=webgl.plane.js.map","map":{"version":3,"file":"webgl.plane.js.map","sources":["webgl.plane.js"],"sourcesContent":["window['#webgl.plane']=function(exports,module){  \"use strict\";\r\nvar Widget = require(\"wdg\");\r\n\r\n/**\r\n * @example\r\n * var Plane = require(\"webgl.plane\");\r\n * var instance = new Plane();\r\n * @class Plane\r\n */\r\nvar Plane = function(args) {\r\n  if (typeof args === 'undefined') args = {};\r\n  if (typeof args.canvasId === 'undefined') args.canvasId = \"glcanvas\";\r\n  if (typeof args.fragmentShaderId === 'undefined') args.fragmentShaderId = \"fragment-shader\";\r\n  if (typeof args.uniform === 'undefined') args.uniform = {};\r\n  if (typeof args.texture === 'undefined') args.texture = {};\r\n  if (typeof args.resolution === 'undefined') args.resolution = 2;\r\n\r\n  this._args = args;\r\n\r\n  var canvasId = args.canvasId;\r\n  var canvas = document.getElementById(canvasId);\r\n  if (!canvas) {\r\n    throw Error(\"Canvas not found with this id: \" + canvasId);\r\n  }\r\n  var fragmentShaderId = args.fragmentShaderId;\r\n  var fragmentShaderElement = document.getElementById(fragmentShaderId);\r\n  if (!fragmentShaderElement) {\r\n    throw Error(\"Fragment shader not found with this id: \" + canvasId);\r\n  }\r\n  var fragmentShader = fragmentShaderElement.textContent.trim();\r\n  var rect = canvas.getBoundingClientRect();\r\n  var W = rect.width;\r\n  var H = rect.height;\r\n  canvas.setAttribute(\"width\", W / args.resolution);\r\n  canvas.setAttribute(\"height\", H / args.resolution);\r\n  var gl = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\r\n\r\n  initShaders.call(this, gl, fragmentShader);\r\n  this._squareVerticesBuffer = initBuffers(gl, W / args.resolution, H / args.resolution);\r\n\r\n  var key, val, texture, textureIndex = 0;\r\n  for (key in args.texture) {\r\n    val = args.texture[key];\r\n    if (typeof val.data === 'undefined') {\r\n      throw Error(\"Missing texture attribute \\\"data\\\" for \\\"\" + key + \"\\\"!\");\r\n    }\r\n    if (typeof val.width === 'undefined') {\r\n      throw Error(\"Missing texture attribute \\\"width\\\" for \\\"\" + key + \"\\\"!\");\r\n    }\r\n\r\n    if (!Array.isArray(val.data)) {\r\n      throw Error(\"Textures must be arrays of Uint8! It is not the case of \\\"\" + key + \"\\\"!\");\r\n    }\r\n    // Make sur data is an array of UNSIGNED_BYTE.\r\n    val.data = new Uint8Array(val.data);\r\n    var tex = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, tex);\r\n    var width = val.width;\r\n    var height = Math.floor((val.data.length >> 2) / width);\r\n    gl.texImage2D(\r\n      gl.TEXTURE_2D,     // target\r\n      0,                 // level\r\n      gl.RGBA,           // internal format\r\n      width, height,     // width, height\r\n      0,                 // border\r\n      gl.RGBA,           // format\r\n      gl.UNSIGNED_BYTE,  // type\r\n      val.data           // data\r\n    );\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\r\n    gl.generateMipmap(gl.TEXTURE_2D);\r\n    var location = gl.getUniformLocation(this._shaderProgram, key);\r\n    gl.activeTexture(gl.TEXTURE0 + textureIndex);\r\n    gl.bindTexture(gl.TEXTURE_2D, tex);\r\n    gl.uniform1i(location, textureIndex);\r\n    textureIndex++;\r\n  }\r\n\r\n  this._gl = gl;\r\n  this._started = false;\r\n};\r\n\r\n\r\n/**\r\n * @return void\r\n */\r\nPlane.prototype.start = function() {\r\n  var that = this;\r\n  var gl = this._gl;\r\n  var uniform = this._args.uniform;\r\n  this._started = true;\r\n\r\n  function render(time) {\r\n    //gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, that._squareVerticesBuffer);\r\n    gl.vertexAttribPointer(that._vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);\r\n\r\n    var f = that._args.render;\r\n    if (typeof f === 'function') {\r\n      f(time, uniform);\r\n    }\r\n\r\n    var key, val;\r\n    for (key in uniform) {\r\n      val = uniform[key];\r\n      gl.uniform1f(gl.getUniformLocation(that._shaderProgram, key), val);\r\n    }\r\n    // Draw the square.\r\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n    if (that._started) {\r\n      window.requestAnimationFrame(render);\r\n    }\r\n  }\r\n\r\n  window.requestAnimationFrame(render);\r\n};\r\n\r\n\r\nfunction initShaders(gl, code) {\r\n  //  var fragmentShader = getShader(gl, code);\r\n  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n  gl.shaderSource(fragmentShader, code);\r\n  gl.compileShader(fragmentShader);\r\n  if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\r\n    throw Error(\r\n      \"An error occurred compiling the fragment shaders:\\n\"\r\n        + gl.getShaderInfoLog(fragmentShader));\r\n  }\r\n\r\n  var vertexShader = gl.createShader(gl.VERTEX_SHADER);\r\n  gl.shaderSource(vertexShader, \"attribute vec3 aVertexPosition;\\nvarying lowp vec3 vPoint;\\nvoid main(void) {\\n  float x = aVertexPosition[0];\\n  float y = aVertexPosition[1];\\n  if (x > 0.0) {\\n    if (y > 0.0) {\\n      gl_Position = vec4(1.0, 1.0, 0.0, 1.0);\\n    } else {\\n      gl_Position = vec4(1.0, -1.0, 0.0, 1.0);\\n    }\\n  } else {\\n    if (y > 0.0) {\\n      gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);\\n    } else {\\n      gl_Position = vec4(-1.0, -1.0, 0.0, 1.0);\\n    }\\n  }\\n  vPoint = aVertexPosition;\\n}\\n\");\r\n  gl.compileShader(vertexShader);\r\n  if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\r\n    throw Error(\r\n      \"An error occurred compiling the vertex shaders:\\n\"\r\n        + gl.getShaderInfoLog(vertexShader));\r\n  }\r\n\r\n  var shaderProgram = gl.createProgram();\r\n  gl.attachShader(shaderProgram, vertexShader);\r\n  gl.attachShader(shaderProgram, fragmentShader);\r\n  gl.linkProgram(shaderProgram);\r\n\r\n  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n    throw Error(\"Unable to initialize the shader program.\");\r\n  }\r\n\r\n  gl.useProgram(shaderProgram);\r\n\r\n  var vertexPositionAttribute = gl.getAttribLocation(shaderProgram, \"aVertexPosition\");\r\n  gl.enableVertexAttribArray(vertexPositionAttribute);\r\n\r\n  this._shaderProgram = shaderProgram;\r\n  this._vertexPositionAttribute = vertexPositionAttribute;\r\n}\r\n\r\nfunction initBuffers(gl, W, H) {\r\n  var squareVerticesBuffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, squareVerticesBuffer);\r\n  var vertices = [\r\n    W/2,  -H/2,  0.0,\r\n      -W/2, -H/2,  0.0,\r\n    W/2,  H/2, 0.0,\r\n      -W/2, H/2, 0.0\r\n  ];\r\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n  return squareVerticesBuffer;\r\n}\r\n\r\nmodule.exports = Plane;\r\n }\r\n"],"names":["window","exports","module","initShaders","gl","code","fragmentShader","createShader","FRAGMENT_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","Error","getShaderInfoLog","vertexShader","VERTEX_SHADER","shaderProgram","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","useProgram","vertexPositionAttribute","getAttribLocation","enableVertexAttribArray","this","_shaderProgram","_vertexPositionAttribute","initBuffers","W","H","squareVerticesBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","vertices","bufferData","Float32Array","STATIC_DRAW","Plane","require","args","canvasId","fragmentShaderId","uniform","texture","resolution","_args","canvas","document","getElementById","fragmentShaderElement","textContent","trim","rect","getBoundingClientRect","width","height","setAttribute","getContext","call","_squareVerticesBuffer","key","val","textureIndex","data","Array","isArray","Uint8Array","tex","createTexture","bindTexture","TEXTURE_2D","Math","floor","length","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","LINEAR_MIPMAP_NEAREST","generateMipmap","location","getUniformLocation","activeTexture","TEXTURE0","uniform1i","_gl","_started","prototype","start","render","time","that","vertexAttribPointer","FLOAT","f","uniform1f","drawArrays","TRIANGLE_STRIP","requestAnimationFrame"],"mappings":"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"},"dependencies":["wdg"]}