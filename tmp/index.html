{"output":{"innerCSS":{},"outerCSS":{},"innerJS":{},"require":{"raygl.main":1},"initJS":{"APP = require('raygl.main');\nsetTimeout(function (){if(typeof APP.start==='function')APP.start()});":1},"include":{"fragment.c":1},"resource":{},"root":{"children":[{"type":1,"name":"html","children":[{"type":1,"name":"head","children":[{"type":1,"name":"title","attribs":{},"children":[{"type":2,"text":"demo-raytracing-shader"}]},{"type":1,"name":"meta","attribs":{"charset":"utf-8"},"void":true},{"type":1,"name":"meta","attribs":{"name":"viewport","content":"width=device-width, initial-scale=1, maximum-scale=1"},"void":true}]},{"type":1,"name":"body","children":[{"type":2,"text":"\r\n    "},{"type":5,"text":" <script src=\"sylvester.js\"></script> ","pos":31},{"type":2,"text":"\r\n    "},{"type":5,"text":" <w:vertex-shader id=\"vertex-shader\">vertex.c</w:vertex-shader> ","pos":82},{"type":2,"text":"\r\n    "},{"type":0,"name":"x-fragment-shader","children":[{"type":1,"name":"script","attribs":{"id":"fragment-shader","type":"x-shader/x-fragment"},"children":[{"type":2,"text":"//<![CDATA[\nprecision lowp float;\r\n\r\n#define RADIUS 70.0\r\n#define RADIUS_2 (RADIUS * RADIUS)\r\n#define SPARSITY 200.0\r\n#define HALF_SPARSITY (SPARSITY * 0.5)\r\n#define EYE 1000.0\r\n#define DEPTH 10\r\n#define BOUNCES 1\r\n\r\nconst float PI = 3.14159265357;\r\nconst vec3 back = vec3(0.0, 0.0, 0.0);\r\nconst vec4 BLACK = vec4(0.0, 0.0, 0.0, 1.0);\r\nconst vec4 WHITE = vec4(1.0, 1.0, 1.0, 1.0);\r\n\r\nvarying lowp vec3 vPoint;\r\nuniform highp float X;\r\nuniform highp float Y;\r\nuniform highp float Z;\r\nuniform highp float time;\r\nuniform sampler2D colors;\r\n\r\nstruct Sphere {\r\n  bool found;\r\n  vec3 center;\r\n  vec3 shift;\r\n  vec3 impact;\r\n  float radius;\r\n  vec4 color;\r\n};\r\n\r\n// Given the center of the sphere, this function set its current radius and base color.\r\nSphere setRadiusAndColor(Sphere sphere) {\r\n  float colorX = mod(abs(sphere.center.x * 13.954112\r\n                         + sphere.center.z * 73.897458), 1711.0) / 1711.0;\r\n  vec4 g = texture2D(colors, vec2(colorX, 0.5));\r\n  float r = g.y + g.x * time / 900.0;\r\n  g = texture2D(colors, vec2(fract(r), 0.5));\r\n  float p = g.w;\r\n  sphere.radius = RADIUS * (1.0 - p * 0.3);\r\n  vec3 center = sphere.center / SPARSITY;\r\n  colorX = mod(abs(center.x * 13.96 + center.y * 17.84 + center.z * 11.984122), 713.0) / 713.0;\r\n  sphere.color = texture2D(colors, vec2(colorX, 0.5));\r\n  sphere.shift = (vec3(sphere.color) + vec3(-0.5)) * (HALF_SPARSITY - RADIUS - 10.0);\r\n  return sphere;\r\n}\r\n\r\nSphere hitTest(vec3 point, vec3 vector, Sphere sphere) {\r\n  // Compute ray and sphere intersection.\r\n  // https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection\r\n  vec3 v = normalize(vector);\r\n  vec3 o = point;\r\n  vec3 c = sphere.center + sphere.shift;\r\n  float r = sphere.radius;\r\n  vec3 co = o - c;\r\n  float tmp = dot(v, co);\r\n  float delta = tmp * tmp - dot(co, co) + r * r;\r\n  if (delta < 0.0) {\r\n    sphere.found = false;\r\n    return sphere;\r\n  }\r\n  float d = - tmp - sqrt(delta);\r\n  sphere.impact = o + v * d;\r\n  sphere.found = true;\r\n  return sphere;\r\n}\r\n\r\nSphere applyLight(Sphere sphere, vec3 origin) {\r\n  vec4 c0 = sphere.color * 0.1 + BLACK * 0.9;\r\n  vec4 c1 = sphere.color * 0.8 + WHITE * 0.2;\r\n  float r = (dot((sphere.impact - sphere.center) / sphere.radius, vec3(0.0, 0.0, -1.0)) + 1.0) * 0.5;\r\n  sphere.color = c1 * r + c0 * (1.0 - r);\r\n  float d = distance(origin, sphere.impact) / (SPARSITY * float(DEPTH));\r\n  sphere.color *= 1.0 - d;\r\n  return sphere;\r\n}\r\n\r\nvec3 getMainDirection(vec3 point, vec3 vector) {\r\n  // Find in which direction the vector points.\r\n  // There are 6 possible directions : X1, X2, Y1, Y2, Z1 and Z2.\r\n  float x = abs(vector.x);\r\n  float y = abs(vector.y);\r\n  float z = abs(vector.z);\r\n\r\n  if (x > y) {\r\n    // x > y\r\n    if (x > z) {\r\n      // x is the greatest.\r\n      return normalize(vec3(vector.x, 0.0, 0.0));\r\n    } else {\r\n      // z is the greatest.\r\n      return normalize(vec3(0.0, 0.0, vector.z));\r\n    }\r\n  } else {\r\n    // y > x\r\n    if (y > z) {\r\n      // y is the greatest.\r\n      return normalize(vec3(0.0, vector.y, 0.0));\r\n    } else {\r\n      // z is the greatest.\r\n      return normalize(vec3(0.0, 0.0, vector.z));\r\n    }\r\n  }\r\n}\r\n\r\nSphere findSphere(vec3 point, vec3 vector) {\r\n  vec4 color;\r\n  Sphere sphere;\r\n  bool found = false;\r\n  for (int bounce = 0 ; bounce < BOUNCES ; bounce++) {\r\n    vec3 mainVect = getMainDirection(point, vector);\r\n    if (mainVect.x != 0.0) {\r\n      if (mainVect.x > 0.0) {\r\n        sphere.center.x = SPARSITY * floor(point.x / SPARSITY) + SPARSITY;\r\n      } else {\r\n        sphere.center.x = SPARSITY * ceil(point.x / SPARSITY) - SPARSITY;\r\n      }\r\n      for (int loop = 0 ; loop < DEPTH ; loop++) {\r\n        float coeff = (sphere.center.x - point.x) / vector.x;\r\n        float z = point.z + vector.z * coeff + HALF_SPARSITY;\r\n        float y = point.y + vector.y * coeff + HALF_SPARSITY;\r\n        sphere.center.z = SPARSITY * floor(z / SPARSITY);\r\n        sphere.center.y = SPARSITY * floor(y / SPARSITY);\r\n        sphere = setRadiusAndColor(sphere);\r\n        sphere = hitTest(point, vector, sphere);\r\n        if (sphere.found) {\r\n          sphere = applyLight(sphere, point);\r\n          break;\r\n        }\r\n        sphere.center += mainVect * SPARSITY;\r\n      }\r\n    }\r\n    else if (mainVect.y != 0.0) {\r\n      if (mainVect.y > 0.0) {\r\n        sphere.center.y = SPARSITY * floor(point.y / SPARSITY) + SPARSITY;\r\n      } else {\r\n        sphere.center.y = SPARSITY * ceil(point.y / SPARSITY) - SPARSITY;\r\n      }\r\n      for (int loop = 0 ; loop < DEPTH ; loop++) {\r\n        float coeff = (sphere.center.y - point.y) / vector.y;\r\n        float x = point.x + vector.x * coeff + HALF_SPARSITY;\r\n        float z = point.z + vector.z * coeff + HALF_SPARSITY;\r\n        sphere.center.x = SPARSITY * floor(x / SPARSITY);\r\n        sphere.center.z = SPARSITY * floor(z / SPARSITY);\r\n        sphere = setRadiusAndColor(sphere);\r\n        sphere = hitTest(point, vector, sphere);\r\n        if (sphere.found) {\r\n          sphere = applyLight(sphere, point);\r\n          break;\r\n        }\r\n        sphere.center += mainVect * SPARSITY;\r\n      }\r\n    }\r\n    else if (mainVect.z != 0.0) {\r\n      if (mainVect.z > 0.0) {\r\n        sphere.center.z = SPARSITY * floor(point.z / SPARSITY) + SPARSITY;\r\n      } else {\r\n        sphere.center.z = SPARSITY * ceil(point.z / SPARSITY) - SPARSITY;\r\n      }\r\n      for (int loop = 0 ; loop < DEPTH ; loop++) {\r\n        float coeff = (sphere.center.z - point.z) / vector.z;\r\n        float x = point.x + vector.x * coeff + HALF_SPARSITY;\r\n        float y = point.y + vector.y * coeff + HALF_SPARSITY;\r\n        sphere.center.x = SPARSITY * floor(x / SPARSITY);\r\n        sphere.center.y = SPARSITY * floor(y / SPARSITY);\r\n        sphere = setRadiusAndColor(sphere);\r\n        sphere = hitTest(point, vector, sphere);\r\n        if (sphere.found) {\r\n          sphere = applyLight(sphere, point);\r\n          break;\r\n        }\r\n        sphere.center += mainVect * SPARSITY;\r\n      }\r\n    }\r\n    // Looking for the next ray bounce.\r\n    if (bounce > 0) {\r\n      if (sphere.found) {\r\n        color = color * 0.8 + sphere.color * 0.2;\r\n      }\r\n    } else {\r\n      found = sphere.found;\r\n      color = sphere.color;\r\n    }\r\n    point = sphere.impact;\r\n    vector = reflect(vector, sphere.impact - sphere.center);\r\n  }\r\n  sphere.found = found;\r\n  sphere.color = color;\r\n  sphere.color.w = 1.0;\r\n  return sphere;\r\n}\r\n\r\n\r\nvoid main(void) {\r\n  vec3 point = vec3(X, Y, Z);\r\n  vec3 vector = vec3(vPoint.x, vPoint.y, EYE);\r\n  Sphere sphere = findSphere(point, vector);\r\n  if (sphere.found) {\r\n    gl_FragColor = sphere.color;\r\n  } else {\r\n    gl_FragColor = vec4(back, 1.0);\r\n  }\r\n}//]]>"}]}],"pos":159},{"type":2,"text":"\r\n    "},{"type":1,"name":"div","attribs":{"id":"container"},"children":[{"type":2,"text":"\r\n        "},{"type":1,"name":"canvas","attribs":{"id":"glcanvas","width":"256","height":"256"},"children":[],"pos":265},{"type":2,"text":"\r\n    "}],"pos":235},{"type":2,"text":"\r\n    "},{"type":1,"name":"center","attribs":{},"children":[{"type":2,"text":"\r\n        "},{"type":1,"name":"button","attribs":{"id":"res4","onclick":"res(4)"},"children":[{"type":2,"text":"Low res."}],"pos":357},{"type":2,"text":"\r\n        "},{"type":1,"name":"button","attribs":{"id":"res2","onclick":"res(2)"},"children":[{"type":2,"text":"Medium res."}],"pos":419},{"type":2,"text":"\r\n        "},{"type":1,"name":"button","attribs":{"id":"res1","onclick":"res(1)"},"children":[{"type":2,"text":"High res."}],"pos":484},{"type":2,"text":"\r\n        "},{"type":1,"name":"p","attribs":{},"children":[{"type":2,"text":"Touch and grab to change the flying direction."}],"pos":547},{"type":2,"text":"\r\n    "}],"pos":339},{"type":2,"text":"\r\n"}]}],"pos":0}]}}}